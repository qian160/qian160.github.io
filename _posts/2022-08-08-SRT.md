---
title: 'SRT除法的一些思考'
date: 2022-08-08
permalink: /posts/2022/08/SRT/
tags:
  - SRT算法
  - 除法器
  - verilog
---

​		这篇文章是我本人在学习SRT除法的过程中得出的一些感悟，主要是想阐述思想，好让将来的自己回过头来看的时候还能想起一些东西。对一些细节就没有过多的深入探究了，可能也会有不够严谨的地方。当初学习这个算法的时候发现它在网上的资料非常之少，好不容易能找到的一些也是写的比较抽象，所以学的很痛苦。最后我根据[**这份附录**](https://eva.fing.edu.uy/pluginfile.php/199462/mod_folder/content/0/a_quantitative_approach_appendix_j.pdf)终于是弄明白了一些东西，打算分享出来，如果也能帮助到需要的人就更好了。也强烈推荐大家可以去看一下那个附录，里面从实用的角度出发对SRT除法作了非常棒的介绍。

​        在介绍SRT除法之前，需要先了解恢复（restoring）除法。而了解恢复除法又需要借助非恢复（non-restoring）除法。所以干脆都列举一遍。这两个算法比较简单可以快速消化。不过得留意下面的结构图。后面介绍的所有除法用的都是这同一套结构，初始化工作也都一样：要计算a/b，我们先把P，A，B这三个寄存器分别初始化为0，a，b。在移位时，A的高位会进入P；而A的最低位根据P高位的情况来设置。

​        （注：书中可能是为了简便起见，里面举的例子主要都是基于**无符号**数进行讲解的）

​        如果上面的链接打不开的话就去看原书好了，我也分享一份，SRT除法的内容出现在附录J 链接：https://pan.baidu.com/s/1-bEcDRPhIYA7_Q3VsPHNQQ  提取码：dnp0

![img](https://pica.zhimg.com/80/v2-6a948173e365fb601bce52fe95d7c962_720w.png?source=d16d100b)





结构图

## restoring

​        也叫试商法，这个的原理比较简单，就是模拟了我们手算的过程。当计算结束后，P中留下的就是余数，A中的则是商。这里还用到了个小优化，我们没有把商单独存放到某个地方，而是和A放到了一起，这节省了硬件资源。这是可以放心的因为在整个除法过程中，随着不断移位，A原来的的每一位都有机会进入P。而这些bits也只有在进入P后才会对结果产生影响。与此同时除法产生的商被不断存到A的低位，并且这些低位的bits在之后都是没有办法进入P的。也就没有机会对结果产生影响。其他的就不多解释了。

![img](https://picx.zhimg.com/80/v2-bae452855805b2b22b32d82bff9a6878_720w.png?source=d16d100b)





恢复除法的操作过程

​        如果有不熟悉的地方可以跟着步骤来一遍，会发现这个计算过程和我们的手算基本上是一样的。就是人比较聪明能一眼看出大小关系，计算机比较笨，他是通过先做差，再根据结果的符号来判断大小关系。算法中的“恢复”二字也是体现在了这里，因为当发现某一步其实不能减的时候要把原来减掉的数据加回去。一开始算出来的商位占用的权重较大，后算出来的权重较小。这在不断的移位中也得到了体现。

![img](https://pica.zhimg.com/80/v2-0ae1609614fb3d27b7ea78d0a95c190d_720w.png?source=d16d100b)





恢复除法的示例

## non-restoring

​        这个稍微巧妙一些。“非恢复”就是省去了恢复除法中，当发现作出来的差是负数的时候，要把B加回去的那一步，整个过程比较一气呵成。具体的操作步骤如下：

![img](https://pic1.zhimg.com/80/v2-971905f99f0305f1e6d907f4c375eff1_720w.png?source=d16d100b)





不恢复除法的操作过程

注意这里有**两次符号检查**：一次是在最开始选择操作分支的时候，还有一次是在最后设置商的时候(步骤iii，这步是公共操作，虽然他在图中看起来被包括在了b分支里面)。在恢复除法中，我们保证了每轮进入循环时，遇到的余数P都是非负的。但在非恢复除法中允许一开始进入循环时遇到负的P。还有个特点是非恢复除法在每次循环中都只要进行一次加法或者一次减法，而恢复除法则最多可能需要一加一减一共两次运算。所以虽然它增加了一些额外的符号检查逻辑，总的开销可能还是更小一些。

还有一个值得注意的地方是在算完所有n个循环后，不恢复除法可能会产生一个负的余数，这时候仍然会需要一个恢复操作。但在整个处理过程的其他地方中都不会涉及到恢复操作。

![img](https://picx.zhimg.com/80/v2-4f729b26b2c73b9515bb797201c2b263_720w.png?source=d16d100b)





不恢复除法的示例

​        不恢复除法的正确性有点不那么明显，书上给出的证明思路是这样的：因为我们已知恢复除法是正确的，所以证明他和恢复除法的效果等价就好。假设  是进行到第k轮循环时，(P,A) 寄存器组中一开始时的值（不包括低位的商）。在恢复算法中，完成步骤( i ) 和步骤( ii )后会得到  这个值，之后根据这个值的正负性进行讨论：

- 假如 ≥ 0，两种算法会以相同的(P,A) =  结束本轮循环；（讨论的是无符号数，因此有b≥0。 如果 ≥ 0，一开始的  肯定也是≥0，非恢复除法会进入处理正数的分支）
- 假如< 0，恢复除法会马上把(P,A)恢复到  ，作为本轮循环产生的结果。并在下一轮循环的计算中得到  ；非恢复除法不马上做调整，而是保留着(P,A) =  这个负值并结束本轮循环。在下一个循环中，会进入处理负数的分支，然后计算出的结果也是  。

​        因此两种算法的处理效果会是一样的。理解了这个非恢复原理后对后面讨论的SRT除法会有帮助。

![img](https://picx.zhimg.com/80/v2-d3e77c9113372eb46ccc30f09bb93af8_720w.png?source=d16d100b)





书上关于非恢复除法的证明

然后还提到了一个小细节：除法运算中P的位数至少要有n+1位。这是为了能够正确检测符号。例如运算中间过程中产生的这个东西：  ，假如  一开始就是一个比较大的正数，经过这番操作后可能就会超出n位的表示范围。同样的  也有可能会溢出。比如  一开始是一个正数，并且能够减去b。但移位后变成了负数，操作一番后最终产生也是负数，结果被认定为了不能减。

![img](https://pica.zhimg.com/80/v2-328c0253deb7ae0737ecd9dee0ec8a85_720w.png?source=d16d100b)





添加图片注释，不超过 140 字（可选）

## SRT-2

​        SRT算法也属于非恢复除法，因为它的每个步骤也很一气呵成，不用考虑马上纠错（恢复）什么的。书上没有给出这个算法的证明过程，不过感觉可以不用太纠结，弄清楚它的思路就好。书上先介绍的是SRT-2，它的效果其实并不特别突出，但可以作为理解高阶SRT算法的开始。

​        引入：（J-45页）关键从第三行开始，感觉大概是在说，计算除法不妨换一种思考方式：要计算a/b，我们每次可以尝试从当前余数中减去**多几倍**的b（而不是每次一倍一倍地减），然后记录共减去了多少倍。这么想是因为当余数很小时，前面提到的两种除法的做法都是仍然会尝试直接拿这个小余数去和b做较量，而这在很多时候都是没有胜算的，我们希望每次的较量都足够有意义，这样就可以提高每次计算的**性价比**。我感觉SRT算法的关键就在这里。（后面会讲到如何体现这个性价比）

于是我们可以不用马上减，而是只移位，这次先不减等下次余数攒大了再一起减。当然这需要额外的硬件支持，来记录b被减了几次

![img](https://picx.zhimg.com/80/v2-bdfd3a9b9bc29849d8e906b86cd8f9ba_720w.png?source=d16d100b)





引入

然后紧接着书上就给出了SRT算法的操作步骤和一个示例（我觉得直接看应该是看不懂，可以先不用管它，先看完后面的分析再回过头来看这个操作步骤）：

![img](https://picx.zhimg.com/80/v2-ed6ac22114089ab68a45e9148200d64a_720w.png?source=d16d100b)





添加图片注释，不超过 140 字（可选）

![img](https://pica.zhimg.com/80/v2-8bd27577811b332c7f556fe9805875ac_720w.png?source=d16d100b)





示例

在引言中提到了，普通除法在面对小余数的时候显得不够高效。这就像是在比赛中，两个人要决出胜负，然后我们不管三七二十一让他们两个先打一场，打完后当然就知道了他们的实力情况到底如何。但其实**有些信息**我们在赛前就可以知道了。比如稍微瞥一眼选手的体格，发现选手A浑身肌肉，另一个选手B有点发育不良，这时候不用比基本上也知道A会赢。如果再借助一些其它信息，我们甚至有办法可以进一步判断出，即使两个B一起上也打不赢A。

​        SRT算法在每个循环中都综合考虑了余数和b的实力悬殊情况，从而帮助做出更高效的决策。有了这些认识后，我们再正式开始讲解SRT算法的步骤。

​        书上对于算法的分析：

![img](https://pica.zhimg.com/80/v2-eceba556e280dfbc599062523ffec31f_720w.png?source=d16d100b)





添加图片注释，不超过 140 字（可选）

他举例的时候用的是小数。我对整数比较习惯所以还是拿整数来举例好了，思想应该是差不多。这里为了之后讲起来方便我先定义 ，于是一个n位**无符号**数B的表示范围为：[0**，M]。**第一步先算出B有k位前导0，然后把B和(P,A)一起左移k位。做完这第一步后保证了b的最高位是1（不考虑除0），从而有**B ＞ 1/2 M**。这么做主要是为了配合后续的步骤。因为我们之后的每步都是要综合考虑R与B的关系来做出决策，所以在一开始就给B设定了一个标准，方便之后用来对照。继续看下去就会明白。

P是n+1位补码表示，每一位的权重分别是：  ，理论范围大约达到了（-M, M），但实际操作中不会用到那么大的范围

每轮循环中，都要检查P前三位的情况，这个操作乍一看可能有点莫名其妙，其实这是在**检查余数R所属的范围**。这时候的根据检查结果就区分出了三种情况：

a.P的前三位相同，此时可以分析出：**-1/4 M < R < 1/4 M** 。(对于正数，前3位全0，损失了1/2 + 1/4 = 3/4的权重。对于负数，前3位全1，获得了-1+1/2 + 1/4 = -1/4的权重)。对应的操作是计算2R，q=0

b.前三位不相同而且是负数：**R < -1/4 M**（110 1111...1）。对应的操作是计算2R+B，q=-1

c.前三位不相同而且是正数：**R > 1/4** **M**（001 0000...0）。对应的操作是计算2R-B，q=1

这就是算法步骤背后的含义：**根据余数所处的范围来选择不同的操作**。

![img](https://pic1.zhimg.com/80/v2-80f80ce2a9f27cf2f19224d7d6681047_720w.png?source=d16d100b)





添加图片注释，不超过 140 字（可选）

书上还说**很容易**得到，整个过程中我们会把R限定在(-b, b)这个范围内，并且也没给出证明。但我感觉这个结论是有点不太显然的。情况a还好，操作前后都会落在范围内。但bc似乎都是单边的，怎么确定他会不会越界？

理解这个的关键可能在于：这是一个迭代的过程，所以每一步实际能有的变化范围会受到前一步的限制。在一开始的时候，(P,A)的移位位数k最多只有n-1（此时b=1。只有b=0的时候才可以移n位，但这意味着除0），此时初始P的前三位最多也就是**0**(-M)**0**(1/2M)**1**(1/4M)，这时候就算后面全是1加起来总共也才1/2M < b，所以**初始值必然会落在我们的区间内**。之后都是基于这个初始值进行不断的迭代。

直接从数学上证明感觉不方便，也不直观。我们可以结合后面提到的**Robertson图**来理解这个迭代过程。x轴是本轮一开始时余数R的值，y轴是经过映射后进入下一轮的余数。SRT-2里用到的映射函数（从左到右）分别是2R+b、2R、2R-b，这些函数有不同的适用区间。

![img](https://picx.zhimg.com/80/v2-7b984206ff1c0ce329d7eb7f044a66fc_720w.png?source=d16d100b)





Robertson图

这里我画了一条**斜率为1**的辅助线（红色）用来做参考，用来判断一个映射是会把值放大、还是减小。在x轴上随便找个点，再沿着y轴找到它对应的函数值。如果函数值和红线重合，说明这次映射没有改变值；如果在红线上方，说明这次映射增大了值；同理在红线下方的是减小值。例如最左边的那个函数永远在红线上方，所以它一直是发挥增大值的效果。

如果考虑的是绝对值，那么只有中间那个函数具有增大绝对值的效果，旁边两个函数都会减小绝对值，并且它们的作用范围都在区间内。也就是说**如果想要跳出区间，那么只有中间的函数有可能办到**。但中间函数能产生的最大值就是b，如果产生了b，下一轮迭代就会进入右边的函数，而那个函数在b处的值会和红线重叠，从而阻止了进一步增大的可能性；如果产生的余数r不是b而是满足：b/2<r＜b，情况就更好了，它进入的仍然是右边的函数，而且经过下一轮处理后会把值变小，这更不可能超出范围了；如果产生的数还是落在中间的范围内，那么下一轮继续×2，最终迟早会落入两边的函数，但不会落到区间外面。

所以这里没有把 | r | > b的部分接着画下去了，因为旁边两个函数都只能接触到| r | ≤ b的值。

这里我一开始存在的一个疑惑是：Robertson图讲的是根据**r和b**的关系来做操作，但每次我们检查p的前几位的时候，得到的应该是**r和M**之间的关系，怎么突然就把r和M的关系转化到r和b去了？不过后来当我继续往下阅读时，发现了SRT除法会在一开始时根据b的初值设置不同的查找表，相当于是考虑到了b和M之间的转换吧。

总的来说，我认为结论之所以成立的两个关键原因是： 1.初始值满足结论 2.迭代过程中出现了重合，也就是图像中（b，b）和（-b，-b）这两个点的存在

这里的图像中还出现了重叠，貌似是因为srt算法其实对商采取了特殊的编码策略，导致产生的结果可以不唯一。好比十进制数999，我们可以直接正向表示为999=900+90+9，也可以负向表示为 =1000-1这样的形式，这个叫作冗余数表示系统。

![img](https://picx.zhimg.com/80/v2-233b7b1227402c22959d1b0df67337e6_720w.png?source=d16d100b)





添加图片注释，不超过 140 字（可选）

现在再回过头去看那个操作过程，应该稍微容易理解一些了吧

还有一个值得讲的地方是SRT算法中对商进行了特殊的编码，示例中直接像  这样表示再我们看起来是很方便，但对计算机来说肯定是还需要对这些数做一些进一步的处理的，而且也没有办法把这些商放到A的低位了。书上给出的一种方法是：设置两个累加器，一个用于保存正商另一个保存负商。每轮循环产生一个商后，把它附加上相应的权重后加入对应的累加器中。最后除法结束后计算两个累加器的差，得到的就是商。

![img](https://pic1.zhimg.com/80/v2-37cd02c831d0f4c233bab5fc79adb634_720w.png?source=d16d100b)





对商的处理

书上关于SRT-2最后部分的一些介绍，主要是讲了他和非恢复算法的一些区别，以及准备引入后面更高阶的SRT算法：

![img](https://picx.zhimg.com/80/v2-17de5c9237914c75595f2467c547f417_720w.png?source=d16d100b)





添加图片注释，不超过 140 字（可选）

## SRT-4

​        从SRT-2中我们了解到，可以通过观察一个数的前几位来得知它所属的范围，利用得到的这个范围信息可以辅助我们做出更好的判断。直观理解起来的话，观察的越详细，应该可以做出越有价值的判断。SRT-4的做法就是如此，它一次观察了更多位，获得的范围信息就更具体，从而可以更大胆地做出判断。SRT-4里面用到的商集是{ -2，-1，0，1，2}。

不过书上对于高阶SRT算法就没有太多介绍了，主要是在贴结论。不过他在思想和流程上都和SRT-2没什么区别，就是在设计上有一些不同之处需要考虑，这里我也直接拿出几个结论：

1. R的范围应该被限制在 | R | ≤ 2/3 B
2. 每次需要检查6位的P，还要检查4位的B
3. Robertson图里的区间端点需要重新设计

这个是对应的Robertson 图：

![img](https://picx.zhimg.com/80/v2-68c5f6941d95b82a8d5cf9ad79103578_720w.png?source=d16d100b)





原图

后面我对这些结论做一些自己的解释。

结论1的证明：这个比较简单。关于如何找边界，其实就是一个解方程的问题，要找出迭代过程中的重合。比如对于右边界那个2b/3，解这个方程：  ，得到  。左边界也是同理

至于图像上像b/12、b/6、b/3等这些端点也可以通过解方程得到。但原图里的线段其实画太短了，我先把它延长再做进一步的讨论比较方便。而且书上的图画的有点小问题，因为x轴上的那些区间端点是根据斜率等于4设计的，但图像的实际斜率并不是4，只有当两者匹配的时候通过延长线段才能在图像上围出正方形，不过问题也不大。

![img](https://picx.zhimg.com/80/v2-b2df6d47815e2acb6e1e08ce196b7c31_720w.png?source=d16d100b)





添加图片注释，不超过 140 字（可选）

先用蓝线画出了2b/3这个边界，然后先延长最左边和最右边的两个函数，他们比较好处理。对于最右边的函数  ，把右边界  带入确实满足  =2b/3，左边界则是把  带入，去解方程  ，解得  也就是左边界。所以最右边函数的适用范围就是(b/3, 2b/3)。区间长度位b/3，中点为b/2，也就是x轴最右边那个黑点。

获取到这个信息后，处理其他函数就可以不用那么麻烦了，可以在区间上采取平均分配的策略。比如从右往左数的第二个函数，可以先找它的中点。容易看出来他应该是原点到刚得出的那个b/2的中点，也就是b/4。然后分别往左和往右扩展半个区间长度b/6，就得到b/12和5b/12，于是这个函数的适用范围就是(b/12, 5b/12)。其他函数也是同理。

至于第二个结论中，6和4这两个数该怎么得出来，书上貌似说的是通过写程序凑出来的

![img](https://picx.zhimg.com/80/v2-3a87e734daeec29603645d42bad1e819_720w.png?source=d16d100b)

添加图片注释，不超过 140 字（可选）

最后，知道了每个函数的适用范围后，每轮循环中检查P确定余数范围后就可以对它采取相应的操作了。不过前面有提到，检查P的前几位这个操作得到的是余数r和M之间的关系，不是r和b。而我们需要根据r和b的关系来做判断。所以这里还需要有一种转化。书上的办法是：

先根据b的高4位（移位后首位必定为1)所有的取指情况设立查找表，不同查找表里对P范围的要求不一样。然后在算法一开始的移位结束后，**检查b的前4位**。根据其取指情况再进入到不同的查找表。不过这个表中的数据具体是怎么来的书上也没给出说明，不过感觉说起来可能挺麻烦的，我也没去深究。

![img](https://pic1.zhimg.com/80/v2-f9f4dd218e6f8f02777294b34175b1a1_720w.png?source=d16d100b)





查找表

![img](https://pica.zhimg.com/80/v2-7eafb4a24c6bf407d50c9f5494cdc7a9_720w.png?source=d16d100b)





SRT-4示例

最后总结一下，SRT-k的迭代过程可以用这个式子来描述： ，算法的一般流程如下：

1. 先把B和(P,A)一起左移k位，使得B的最高位为1，这保证了B>1/2M。方便了后续拿着余数和B作比较
2. 每轮循环中，检查P的前几位，通过这个操作可以确定余数P所属的范围。当P和B的范围都被确定后，我们就可以对症下药，做出最适合当前情况的操作
3. 计算结束后可能还需要做恢复工作，因为这时候P里面的值可以是负数。恢复结束后。再把(P,A)右移k位，这时候P里面存放的才是余数

我觉得SRT算法巧妙的地方在于：他通过一些小手段确定了余数和除数的范围，然后根据额外拿到的这个范围信息来辅助做决策。这样做出的决策就会更高效，根本不需要试探

顺带一提，我之前用chisel写代码的时候，发现计算前导0个数有个很轻松的方法：

```
object countLeadingZeros{
    def apply(in:UInt):UInt = PriorityEncoder(Reverse(in))
}
```

PriorityEncoder返回从右往左数的第一个1的位置，Reverse将bits反转，这样就相当于是返回从左往右数的第一个1的位置了

大概思路和步骤就是这样了。附录里有写更多的细节，再次强烈推荐去看。

我[这里](https://github.com/qian160/SRT4-div)还用verilog写了个8位版本的代码出来，基本上就是按照书上的讲解来写的，不过在编写的时候我的数字电路水平比较一般，所以不要嫌弃我的代码质量。主要是提供一些思路。在我的设计中总共需要花费1+4+1=6个周期。第一个周期做左移和初始化，最后一个周期对结果做调整。对于有符号除法的处理是，先把他们都转化成正数，然后按照无符号除法的方法来计算他们。算完后再对结果的符号做修改。