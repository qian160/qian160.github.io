---
title: '乘法器学习总结'
date: 2024-06-24
permalink: /posts/2024/06/mult/
tags:
  - 乘法器
  - Wallace tree
  - booth编码
  - verilog
---

最近在学习乘法器，感觉比较有意思所以想分享一下。主要是分享思路，对数学证明等的一些具体细节没有深究。供大家参考学习以及自己日后的复习。
首先是最简单的乘法器，这个感觉没什么好说的，就是先生成全部的n个部分积然后把他们加起来，跟我们手算乘法那个过程差不多。

添加图片注释，不超过 140 字（可选）
实现起来很简单，但是性能不好：最长的路径大约有2n长度。这里可能值得注意的就是有符号跟无符号乘法的区别吧。教材上的说法一般是无符号乘法就对部分积采取零扩展，有符号乘法可能要先把乘数转化成正数，然后按照无符号的方式来处理他们。最后算完后再考虑要不要把结果取负。ppt上还讲到了另外一种方法，不过我没怎么看，貌似用到了一些数学技巧：

添加图片注释，不超过 140 字（可选）
还有一种多周期的"shift-add"结构的乘法器，也比较简单。但是性能也不怎么好，不过好在节省空间和低功耗。

添加图片注释，不超过 140 字（可选）
这里我主要想分享的是另外一种更高效的乘法器，里面主要用到了进位保存加法器(Carry Save Adder)和booth编码这两个东西。所以首先来介绍一下他们。
csa
常规的加法器(这里作为对比的是cpa，carry propagate adder)，可以抽象理解成是输入两个数然后产生一个数(a + b = s)，实现的是2->1的映射。csa是输入三个数，产生两个数，然后这两个数的和会等于输入的三个数的和(a + b + c = d+ e)，是一个3->2的映射。乍一看似乎没什么了不起的，本来好好的计算a+b+c，你跑去计算d+e干什么。而且最终不还是要把两个数加起来吗？
这里的核心在于：d、e两个数其实是某种中间结果，很快就可以产生，从而更快启动后面的加法器。
当要相加的数据个数很多时（比如乘法产生的部分积），不管是csa还是cpa，用一次都能起到消除一个操作数的效果(csa虽然还没有产生最终结果，但它把参与运算的数从3个减少为2个，也算是消除了一个操作数)。但是cpa每次处理掉一个数时，要处理一次进位链的问题，输出更慢，后面的加法器都等不及了。而csa产生那些中间结果的时候只做了一些逻辑运算，数据之间没有相关性，输出更快。

添加图片注释，不超过 140 字（可选）
具体来说，csa产生的两个中间结果，分别是每个位置上的进位情况，以及不考虑进位时的加法结果。如果把这两个数再加起来其实就等于输入三个数相加的结果了，但是我们不那么做。
以下是我写的一个简单的csa模块，逻辑比较容易：

添加图片注释，不超过 140 字（可选）
1.进位信息carry，取决于1的个数是否大于1。3个数中只要有两个1就会产生进位
2.不考虑进位时的加法结果t，取决于1个数的奇偶性。偶数个1相加会得到0，反之得到1
最终输出的两个数会等于输入三个数的和，这个应该不难理解。这里我对carry用了一个左移1的操作是为了后续的一些方便性。因为一个进位信息虽然是在位置i处产生，但是他参与的是位于i+1处的运算，而不是i。端口宽度乘2也是为了方便。因为乘法运算产生的最终结果是2 × WIDTH宽度的，干脆就把中间结果也统一设置成了2 × WIDTH宽度
最后按照树形结构排列这些csa，就得到了一个叫做华里士树的东西。对比前面的第二张图，路径长度从线性级别被降低到了对数级别。

添加图片注释，不超过 140 字（可选）


添加图片注释，不超过 140 字（可选）
每个csa都不直接处理加法，而是通过他的方式先不断减少操作数的个数。等到最后减到只剩两个操作数了，才开始处理真正的加法。整个运算过程中，进位链有且仅有在最后一步被处理了一次。而cpa处处都在处理进位链。即使采取超前进位等一些手段，效果应该也比不过csa。
因为每经过一个csa，参与运算的操作数个数就减少一个，所以可以分析得出，n个数相加时，一共需要n-2个csa才能把数减少到2个。
华里士树刚被提出时，文章里用到的是3-2压缩的csa。后来的人们经过改造，也可以用4-2、5-2压缩的器件来构成树形结构。由于经常要面对的是偶数个数据相加，所以使用3输入的csa就有些不太方便。4-2比较方便，但是实现起来稍微有点复杂，这里我想到的是一个比较偷懒的实现：

添加图片注释，不超过 140 字（可选）
booth编码
在了解booth编码之前，我们先要了解booth算法。其核心思想在于：任何一串连续的二进制1都可以被分解为两个二进制1的加减。booth算法就是根据这个原理，把一些加法转化成了减法。不过注意该算法只适用于有符号乘法。

添加图片注释，不超过 140 字（可选）
这里也可以举一个生活中的例子：我们在做十进制乘法的时候，对于乘10、乘100、乘1000等等这些整数倍乘法算起来很简单，一眼就能看出答案，直接在末尾补0就可以，类似于二进制中的左移。
而对于非整数倍的乘法，我们利用上面的技巧，有时候也可以做一些简化运算。比如计算a × 999，我们可能会先算a × 1000，再减去 a × 1。而不是老老实实去计算a × 900 + a × 90 + a × 9。
十进制中我们可以很方便地把一串连续的9，例如999分解成1000-1，同样的在二进制中我们也可以把一串1分解成一个加法和一个减法。所以主要问题就变成要找出一串1。这通过booth给出的算法就可以办到，具体可以去看这个：
规则就是里面提到的那些。一开始出现那个方法叫做booth-1，他虽然也可以工作，但仍然产生n个部分积，没有起到压缩的效果。编码结果是这样：
00 -> 0
01 -> +1   一串1的结束(从后往前看，或者从右往左看)
10 -> -1   一串1的开始
11 -> 0    中间的一串1
经过改进后还可以得到更高阶的booth编码。booth-3的结论是这个：

添加图片注释，不超过 140 字（可选）
感觉像是每轮进行了两次booth-1编码，先检查YiYi-1，再检查Yi+1Yi，然后YiYi+1的权重还要乘2。比如101被编码为-1，先检查后两位01得到+1，再检查前两位10得到-1，最后编码为-1 × 2 + 1 = -1。booth-2的编码结果都还比较好看，因为都是0、1、2这几个数，可以通过左移来简单实现。更高阶的booth编码就会出现一些不方便处理的数了。例如这个booth-3，里面出现的3并不好处理：

添加图片注释，不超过 140 字（可选）
下面这张图很形象地展示了booth编码的效果和其中的一些核心观点。

添加图片注释，不超过 140 字（可选）
之前说的“检查一串1”是一种通俗的理解，这里还有一种严谨的数学证明：
对于一个以 n位二进制补码形式表示的乘数A，其值为:
式(1)中， Ai代表数据A的第i位的值。本设计中乘法器输入的乘数 A是32位的，代入式(1)，则可以表示为
于是也能得到同样的Booth-3乘数编码与部分积操作对照表
​  
举例来说，
以下是一个基于shift-add结构的booth乘法操作过程示范（一开始在乘数的最低位补充了一位隐藏的0，便于booth算法的检查）：

添加图片注释，不超过 140 字（可选）
一个实例
我结合两种技术，构造了一个简单的32位有符号乘法器。我画的设计图是这样：

添加图片注释，不超过 140 字（可选）
b0~b15：一层booth编码器。检查a的相应比特，然后输出编码结果
ppg0~ppg15：我封装了一个叫做ppg的模块，意思是"partial product generate"，他会根据booth编码的结果，将b乘以相应的权重，以生成一个部分积。由于ppg中会用到-B这个数，为了避免每个ppg都生成一份-B，我会在一开始的时候就在外面先生成一个-B，然后把它作为输入统一传递给每个ppg模块
至此部分积已经全部生成。后面就是用树形排列的4-2压缩器来处理他们了。当部分积只剩下两个后，用一个全加器生成最终结果
这里有一个注意事项：对于ppg模块，虽然输入的数据是32位，但需要至少32+2=34位来保存中间结果。这是因为booth-2的编码集为{-2、-1、0、1、2}，当输入数据in恰好是-0x80000000时（最小的负数。最高位为1，其它位全0），如果想表示-2in，会超出33位的表示范围。因此至少需要34位
总结来说：booth编码用于减少初始部分积的个数，压缩器用于高效处理那些部分积。
https://github.com/qian160/booth_wallace_mult32_signed
参考资料
https://www.ece.ucdavis.edu/~bbaas/281/notes/Handout.booth.pdf
https://inst.eecs.berkeley.edu/~eecs151/sp18/files/Lecture21.pdf
https://ieeemilestones.ethw.org/w/images/2/2a/A_suggestion_for_a_fast_multiplier.pdf 
https://course.ccs.neu.edu/cs3650/ssl/TEXT-CD/Content/COD3e/InMoreDepth/IMD3-Booths-Algorithm.pdf
https://www.brown.edu/Departments/Engineering/Courses/En164/BoothRadix4.pdf